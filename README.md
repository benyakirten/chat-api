# Table Of Contents

1. [What is this?](#what-is-this)
1. [How do I run this?](#how-do-i-run-this)
1. [Data Models](#data-models)
1. [API (or how do I build a chat client)](#api)
1. [What's missing?](#whats-missing)

## What is this?

It is an Elixir Phoenix-powered backend for a chat server with e2e encryption on all messages. It has an API for performing various account-related functionality, but all management of chat messages are handled through Phoenix channels (a layer of abstraction above web sockets). For this reason, clients must use the [Phoenix JavaScript Client Library](https://www.npmjs.com/package/phoenix) (or build their own version, see [these instructions](https://hexdocs.pm/phoenix/writing_a_channels_client.html)). There are a few ones already out there for other languages, including Swift, Elixir, Kotlin. C# and Java.

## How do I run this?

To start your Phoenix server:

- Clone the repository
- Run `mix setup` to install and setup dependencies.
- Start Phoenix endpoint with `mix phx.server` or inside IEx with `iex -S mix phx.server`

## Environment Variables

Environment variables are not necessary in a development environment. However, the following variables must be defined in a `.env` file for a development environment:

```bash
FRONTEND_URL
FROM_EMAIL
SECRET_KEY_BASE
VAULT_KEY
DATABASE_URL
POOL_SIZE
```

The variables `FRONTEND_URL` and `FROM_EMAIL` are used to send emails, which is not complete. The `SECRET_KEY_BASE` is used for signing API tokens. The `VAULT_KEY` is used for encryption and decryption of public and private keys. The `DATABASE_URL` is used for connection with the database. The `POOL_SIZE` is used to set the size of database connections in the pool. If absent, the `POOL_SIZE` will default to 10.

All of these environment variables are defined in `.env.example` so a quick way to get a copy is to run:

```bash
cp .env.example .env
```

To generate a vault key, you will need to generate 32 bytes and encode them to base 64. An easy way to do this is the following command in iex:

```elixir
32 |> :crypto.strong_rand_bytes() |> Base.encode64()
```

## Data Models

NOTE: This section is incomplete.

The data models revolve around three general archetypes:

1. Users - A user's profile, password, etc.
2. Conversations - A list of conversations that contain users.
3. Messages - These are the individual messages sent in a conversation.

### Users

Users have the following properties:

1. Display name
2. Password
3. Email confirmation time (currently unused)

They have a 1:1 relationship with a profile, which will contain some preferences that aren't publically available. These include:

1. Text Magnification
2. Color Theme Preference
3. Hidden preference (if they're displayed as online)
4. Recently viewed pages

Authentication is done through short-lived tokens (30 minutes). When logged in, a refresh token is also provided, which is valid for two weeks. Refresh tokens can be exchanged for a new auth token and refresh token.

Email confirmation, changing password or changing email is also done through long-lived tokens. Like refresh tokens, these can be revoked at any time. For example, after changing password, all refresh tokens for that user are revoked so the user must authenticate with email/password again.

### Conversations

Conversations come in two varities: private and group. A private conversation is between two users, and new users cannot be added at any time. A group conversation can have an alias. All conversations have a unique public and private key per individual (stored in the `encryption_keys` table). These are stored in the database under encryption using the [Cloak Ecto](https://hexdocs.pm/cloak_ecto/readme.html) library. Since the keys are generated by the client and not the server, no messages should be sent to a conversation until each client has generated and transmitted keys.

### Messages

Messages are pieces of text sent in a specific conversation by one user. When a user sends a message, it must be sent as a series of messages that are already encrypted with the public keys of everyone in a conversation. In terms of the database, each message is stored separately with the ID of the recipient. All messages sent as part of this point to a singular message group, which has the name of the sender. When retrieving messages from a database for a specific user, each message group will be retrieved but only the message for that specific users.

## Rest(ish) API

NOTE: This section is incomplete.

The REST-ish API for client interaction are as follows:
POST `/auth/register`
POST `/auth/login`

The payload for these endpoints should ne:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!"
}
```

<!-- TODO -->

POST `/auth/refresh`
POST `/auth/confirm`
POST `/auth/password/request`
POST `/auth/password/confirm`
POST `/auth/password/reset`

POST `/api/signout_all`
POST `/api/token/email_confirm`
POST `/api/token/email_change`
PATCH `/api/password`
PATCH `/api/email`
PATCH `/api/profile`

## Socket Interactions

<!-- TODO -->

The socket interfaces are divided into three channels (a Phoenix abstraction over sockets):
`system:general`
`user:{uuid}`
`conversation:{uuid}`

The exact parameters of these endpoints and how to use them will be explained later.

## What's Missing

1. Testing and Documentation
2. Fix the email system (emails are not sent so confirmation/changing email and resetting password is not available)
3. Streamline functions/modules, remove redundancies and make sure domain code is entirely contained within it
