# Table Of Contents

1. [What is this?](#what-is-this)
1. [How do I run this?](#how-do-i-run-this)
1. [Data Models](#data-models)
1. [API (or how do I build a chat client)](#api)
1. [What's missing?](#whats-missing)

## What is this?

It is an Elixir Phoenix-powered backend for a chat server with e2e encryption on all messages. It has an API for performing various account-related functionality, but all management of chat messages are handled through Phoenix channels (a layer of abstraction above web sockets). For this reason, clients must use the Phoenix socket interface. For JavaScript, there's the [Phoenix JavaScript Client Library](https://www.npmjs.com/package/phoenix). For other versions, see [these instructions](https://hexdocs.pm/phoenix/writing_a_channels_client.html).

## How do I run this?

To start your Phoenix server:

- Clone the repository
- Run `mix setup` to install and setup dependencies.
- Start Phoenix endpoint with `mix phx.server` or inside IEx with `iex -S mix phx.server`

## Environment Variables

Environment variables are not necessary in a development environment. However, the following variables must be defined in a `.env` file for a development environment:

```bash
FRONTEND_URL
FROM_EMAIL
SECRET_KEY_BASE
VAULT_KEY
DATABASE_URL
POOL_SIZE
```

The variables `FRONTEND_URL` and `FROM_EMAIL` are used to send emails, which is not complete. The `SECRET_KEY_BASE` is used for signing API tokens. The `VAULT_KEY` is used for encryption and decryption of public and private keys. The `DATABASE_URL` is used for connection with the database. The `POOL_SIZE` is used to set the size of database connections in the pool. If absent, the `POOL_SIZE` will default to 10.

All of these environment variables are defined in `.env.example` so a quick way to get a copy is to run:

```bash
cp .env.example .env
```

To generate both the secret key base and the vault key, you can use the handy Phoenix mix task:

```bash
mix phx.gen.secret # Default is 64 bytes
mix phx.gen.secret 32 # The docs recommend 32 bytes, but you should be able to specify longer
```

Or if you want to use elixir:

```elixir
32 |> :crypto.strong_rand_bytes() |> Base.encode64()
```

## Data Models

The data models revolve around three general archetypes:

1. Users - A user's profile, password, etc.
2. Conversations - A list of conversations that contain users.
3. Messages - These are the individual messages sent in a conversation.

### Users

Users have the following properties:

1. Display name
2. Password
3. Email confirmation time (currently unused)

They have a 1:1 relationship with a profile, which will contain some preferences that aren't publically available. These include:

1. Text Magnification
2. Color Theme Preference
3. Hidden preference (if they're displayed as online)
4. Recently viewed pages

Authentication is done through short-lived tokens (30 minutes). When logged in, a refresh token is also provided, which is valid for two weeks. Refresh tokens can be exchanged for a new auth token and refresh token.

Email confirmation, changing password or changing email is also done through long-lived tokens. Like refresh tokens, these can be revoked at any time. For example, after changing password, all refresh tokens for that user are revoked so the user must authenticate with email/password again.

### Conversations

Conversations come in two varities: private and group. A private conversation is between two users, and new users cannot be added at any time. A group conversation can have an alias. All conversations have a unique public and private key per individual (stored in the `encryption_keys` table). These are stored in the database under encryption using the [Cloak Ecto](https://hexdocs.pm/cloak_ecto/readme.html) library. Since the keys are generated by the client, no messages should be sent to a conversation until each client has generated and transmitted keys.

### Messages

Messages are pieces of text sent in a specific conversation by one user. When a user sends a message, it must be sent as a series of messages that are already encrypted with the public keys of everyone in a conversation. In terms of the database, each message is stored separately with the ID of the recipient. All messages sent as part of this point to a singular message group, which has the name of the sender. When retrieving messages from a database for a specific user, each message group will be retrieved but only the message for that specific users.

## Rest(ish) API

All values for payloads and return values are using example data. The field names and types are correct.

The REST-ish API for client interaction are as follows:

### POST `/auth/register`

Create a user with an optional display name.
Payload:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!",
  "display_name": "My Cool Name" // Optional
}
```

If successful, the following data will be returned:

```json
{
  "user": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "email": "test@example.com",
    "display_name": "test@example.com", // Defaults to the email if no display name is given
    "hidden": false,
    "theme": "day", // Options are right now day and night
    "magnification": 1.0, // Value between 0.7 and 1.4
    "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"]
  }
}
```

### POST `/auth/login`

Log in
Payload:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!"
}
```

<!-- TODO -->

POST `/auth/refresh`
POST `/auth/confirm`
POST `/auth/password/request`
POST `/auth/password/confirm`
POST `/auth/password/reset`

POST `/api/signout_all`
POST `/api/token/email_confirm`
POST `/api/token/email_change`
PATCH `/api/password`
PATCH `/api/email`
PATCH `/api/profile`

## Socket Interactions

<!-- TODO -->

The socket interfaces are divided into three channels (a Phoenix abstraction over sockets):
`system:general`
`user:{uuid}`
`conversation:{uuid}`

The exact parameters of these endpoints and how to use them will be explained later.

## What's Missing

1. Testing and Documentation
2. Fix the email system (emails are not sent so confirmation/changing email and resetting password is not available)
3. Streamline functions/modules, remove redundancies and make sure domain code is entirely contained within it
