# Table Of Contents

1. [What is this?](#what-is-this)
1. [How do I run this?](#how-do-i-run-this)
1. [Data Models](#data-models)
1. [API (or how do I build a chat client)](#api)
1. [What's missing?](#whats-missing)

## What is this?

It is an Elixir Phoenix-powered backend for a chat server with e2e encryption on all messages. It has an API for performing various account-related functionality, but all management of chat messages are handled through Phoenix channels (a layer of abstraction above web sockets). For this reason, clients must use the Phoenix socket interface. For JavaScript, there's the [Phoenix JavaScript Client Library](https://www.npmjs.com/package/phoenix). For other versions, see [these instructions](https://hexdocs.pm/phoenix/writing_a_channels_client.html).

## How do I run this?

To start your Phoenix server:

- Clone the repository
- Run `mix setup` to install and setup dependencies.
- Start Phoenix endpoint with `mix phx.server` or inside IEx with `iex -S mix phx.server`

## Environment Variables

Environment variables are not necessary in a development environment. However, the following variables must be defined in a `.env` file for a development environment:

```bash
FRONTEND_URL
FROM_EMAIL
SECRET_KEY_BASE
VAULT_KEY
DATABASE_URL
POOL_SIZE
```

The variables `FRONTEND_URL` and `FROM_EMAIL` are used to send emails, which is not complete. The `SECRET_KEY_BASE` is used for signing API tokens. The `VAULT_KEY` is used for encryption and decryption of public and private keys. The `DATABASE_URL` is used for connection with the database. The `POOL_SIZE` is used to set the size of database connections in the pool. If absent, the `POOL_SIZE` will default to 10.

All of these environment variables are defined in `.env.example` so a quick way to get a copy is to run:

```bash
cp .env.example .env
```

To generate both the secret key base and the vault key, you can use the handy Phoenix mix task:

```bash
mix phx.gen.secret # Default is 64 bytes
mix phx.gen.secret 32 # The docs recommend 32 bytes, but you should be able to specify longer
```

Or if you want to use elixir:

```elixir
32 |> :crypto.strong_rand_bytes() |> Base.encode64()
```

## Data Models

The data models revolve around three general archetypes:

1. Users - A user's profile, password, etc.
2. Conversations - A list of conversations that contain users.
3. Messages - These are the individual messages sent in a conversation.

### Users

Users have the following properties:

1. Display name
2. Password
3. Email confirmation time (currently unused)

They have a 1:1 relationship with a profile, which will contain some preferences that aren't publically available. These include:

1. Text Magnification
2. Color Theme Preference
3. Hidden preference (if they're displayed as online)
4. Recently viewed pages

Authentication is done through short-lived tokens (30 minutes). When logged in, a refresh token is also provided, which is valid for two weeks. Refresh tokens can be exchanged for a new auth token and refresh token.

Email confirmation, changing password or changing email is also done through long-lived tokens. Like refresh tokens, these can be revoked at any time. For example, after changing password, all refresh tokens for that user are revoked so the user must authenticate with email/password again.

### Conversations

Conversations come in two varities: private and group. A private conversation is between two users, and new users cannot be added at any time. A group conversation can have an alias. All conversations have a unique public and private key per individual (stored in the `encryption_keys` table). These are stored in the database under encryption using the [Cloak Ecto](https://hexdocs.pm/cloak_ecto/readme.html) library. Since the keys are generated by the client, no messages should be sent to a conversation until each client has generated and transmitted keys.

### Messages

Messages are pieces of text sent in a specific conversation by one user. When a user sends a message, it must be sent as a series of messages that are already encrypted with the public keys of everyone in a conversation. In terms of the database, each message is stored separately with the ID of the recipient. All messages sent as part of this point to a singular message group, which has the name of the sender. When retrieving messages from a database for a specific user, each message group will be retrieved but only the message for that specific users.

## Rest(ish) API

All values for payloads and return values are using example data. The field names and types are correct.

The REST-ish API for client interaction are as follows:

### POST `/auth/register`

Create a user with an optional display name.
Payload:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!",
  "display_name": "My Cool Name" // Optional
}
```

Return payload (if successful):

```json
{
  "user": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "email": "test@example.com",
    "display_name": "test@example.com", // Defaults to the email if no display name is given
    "hidden": false,
    "theme": "day", // Options are right now day and night
    "magnification": 1.0, // Value between 0.7 and 1.4
    "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"] // Array of strings that are to be interpreted as recently viewed pages
  },
  "conversations": [
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "private": false,
      "alias": "Besties 4eva", // Nullable
      "inserted_at": "2024-01-01T23:38:41.183Z",
      "updated_at": "2024-01-01T23:38:41.183Z"
    }
  ],
  "users": [
    // Information for all users in conversations with the user.
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "email": "test@example.com",
      "display_name": "test@example.com"
    }
  ],
  "auth_token": "SFMyNTY.g2gDbQAAACQ0YjJlMWIwZi03NDBkLTQxMWQtODEzMy1kYzlhYjY2NDBiNWVuBgALsmbHjAFiAAAHCA.fAQMbNHGcPrFJC9KoCNTA03rMgGdXc112Y_shoyRm9g",
  "refresh_token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

### POST `/auth/login`

Log in with an email and password to get an auth token and password.
Payload:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!"
}
```

Returns the same data as the POST `/auth/register` endpoint.

### POST `/auth/refresh`

Exchange a refresh token for a new auth token and refresh token.

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

Return the same data (if successful) as `/auth/register`.

### POST `/auth/confirm`

Mark an email address as confirmed. When a user registers (and emailing functionality is complete), an email is sent to their email address to confirm it. No functionality is hidden behind email confirmation.

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

If successful, a 204 with no content will be returned.

### POST `/auth/password/request`

Payload:

```json
{
  "email": "test@example.com"
}
```

If a user is discovered corresponding to the email, a 204 will be returned and an email will be sent to the email address with a password reset token.

### POST `/auth/password/confirm`

Returns the user that the token belongs to.

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

Return data:

```json
{
  "success": true,
  "user": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "email": "test@example.com",
    "display_name": "test@example.com"
  }
}
```

### POST `/auth/password/reset`

A password reset token will set the password to a new value and revoke all tokens (refresh, confirmation etc.).

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ",
  "password": "VerySecurePassword1!", // Current password
  "new_password": "VerySecurePassword2!", // New Password
  "new_password_confirmation": "VerySecurePassword2!" // Must match the new password exactly
}
```

Returns a 204 if successful.

## API Endpoints

All API endpoints require a `Authorization` header with a value of `Bearer <token>`. A token will only be valid for 30 minutes and identifies the user in the payload.

### POST `/api/signout_all`

Forces all refresh tokens for a given user to be revoked. No payload is required. A 204 response with no data will be returned.

### POST `/api/token/email_confirm`

Requests a new email confirmation token. No payload is required. A 204 response with no data will be returned.

### POST `/api/token/email_change`

Requests a new email change token. No payload is required. A 204 response with no data will be returned.

### PATCH `/api/password`

Changes a user's password. This is different from POST `/auth/password/reset` because it uses a token.

Payload:

```json
{
  "password": "VerySecurePassword1!", // Current password
  "new_password": "VerySecurePassword2!", // New Password
  "new_password_confirmation": "VerySecurePassword2!" // Must match the new password exactly
}
```

If the request is successful then a 204 will be returned and all tokens will be reset for the user.

### PATCH `/api/email`

Change a user's email. It requires both the email change token and the authentication token, meaning it can only happen if the user is logged in.

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ",
  "email": "test@example.com",
  "password": "VerySecurePassword1!"
}
```

If successful, a 204 with no data will be returned.

### PATCH `/api/profile`

Changes the user profile settings including:

1. Text Magnification
2. Theme
3. Recents
4. Hidden status

Payload:

```json
{
  "hidden": false,
  "theme": "day", // Options are right now day and night
  "magnification": 1.0, // Value between 0.7 and 1.4
  "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"] // Array of strings that are to be interpreted as recently viewed pages
}
```

Returned data if successful:

```json
{
  "hidden": false,
  "theme": "day", // Options are right now day and night
  "magnification": 1.0, // Value between 0.7 and 1.4
  "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"] // Array of strings that are to be interpreted as recently viewed pages
}
```

### GET `/api/messages`

Get paginated messages for a conversation. It takes the following required query parameters:

1. `conversation_id` - the UUID of the conversation

Optional query parameters:

1. `page_token` - the page token from the last page retrieved. If no page token is given then the messages will be paginated from the latest messages for the conversation.
2. `page_size` - the amount of messages to retrieve.

The returned data if successful is:

```json
{
  "items": [
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "sender": "5161cb32-2d85-4846-897d-10c336ce701c",
      "content": "Hello", // This will be encrypted using the public key for the user for the conversation
      "inserted_at": "2024-01-01T23:38:41.183Z",
      "updated_at": "2024-01-01T23:38:41.183Z",
      "message_group": "5161cb32-2d85-4846-897d-10c336ce701c" // Message group ID is needed when updating/deleting the message
    }
  ],
  "page_token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ" // Null if there are no more messages for the conversation
}
```

### GET `/api/users`

Get a page of users. It takes two optional query parameters:

1. `page_token` - the page token from the last page retrieved. If no page token is given then the messages will be paginated from the latest messages for the conversation.
2. `page_size` - the amount of messages to retrieve.

The returned data if successful is:

```json
{
  "items": [
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "email": "test@example.com",
      "display_name": "test@example.com"
    }
  ],
  "page_token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ" // Null if there are no more messages for the conversation
}
```

### GET `/api/conversations/private/:user_id`

Returns if the user by the auth token is already in a private conversation with the user by the given user ID. No query parameters will be checked. Returns the following data:

```json
{
  "conversation_id": "5161cb32-2d85-4846-897d-10c336ce701c" // Null if no conversation is found
}
```

## Socket Interactions

<!-- TODO -->

The socket interfaces are divided into three channels (a Phoenix abstraction over sockets):
`system:general`
`user:{uuid}`
`conversation:{uuid}`

A conversation channel will be opened per channel that the user is

The exact parameters of these endpoints and how to use them will be explained later.

## What's Missing

1. Testing and Documentation
1. Fix the email system (emails are not sent so confirmation/changing email and resetting password is not available)
1. Streamline functions/modules, remove redundancies and make sure domain code is entirely contained within it
1. Add OAPI docs for endpoints/socket interactions.
