# Table Of Contents

1. [What is this?](#what-is-this)
1. [How do I run this?](#how-do-i-run-this)
1. [Data Models](#data-models)
1. [API (or how do I build a chat client)](#api)
1. [What's missing?](#whats-missing)

## What is this?

It is an Elixir Phoenix-powered backend for a chat server with e2e encryption on all messages. It has an API for performing various account-related functionality, but all management of chat messages are handled through Phoenix channels (a layer of abstraction above web sockets). For this reason, clients must use the Phoenix socket interface. For JavaScript, there's the [Phoenix JavaScript Client Library](https://www.npmjs.com/package/phoenix). For other versions, see [these instructions](https://hexdocs.pm/phoenix/writing_a_channels_client.html).

## How do I run this?

To start your Phoenix server:

- Clone the repository
- Run `mix setup` to install and setup dependencies.
- Start Phoenix endpoint with `mix phx.server` or inside IEx with `iex -S mix phx.server`

## Environment Variables

Environment variables are not necessary in a development environment. However, the following variables must be defined in a `.env` file for a development environment:

```bash
FRONTEND_URL
FROM_EMAIL
SECRET_KEY_BASE
VAULT_KEY
DATABASE_URL
POOL_SIZE
```

The variables `FRONTEND_URL` and `FROM_EMAIL` are used to send emails, which is not complete. The `SECRET_KEY_BASE` is used for signing API tokens. The `VAULT_KEY` is used for encryption and decryption of public and private keys. The `DATABASE_URL` is used for connection with the database. The `POOL_SIZE` is used to set the size of database connections in the pool. If absent, the `POOL_SIZE` will default to 10.

All of these environment variables are defined in `.env.example` so a quick way to get a copy is to run:

```bash
cp .env.example .env
```

To generate both the secret key base and the vault key, you can use the handy Phoenix mix task:

```bash
mix phx.gen.secret # Default is 64 bytes
mix phx.gen.secret 32 # The docs recommend 32 bytes, but you should be able to specify longer
```

Or if you want to use elixir:

```elixir
32 |> :crypto.strong_rand_bytes() |> Base.encode64()
```

## Data Models

The data models revolve around three general archetypes:

1. Users - A user's profile, password, etc.
2. Conversations - A list of conversations that contain users.
3. Messages - These are the individual messages sent in a conversation.

### Users

Users have the following properties:

1. Display name
2. Password
3. Email confirmation time (currently unused)

They have a 1:1 relationship with a profile, which will contain some preferences that aren't publically available. These include:

1. Text Magnification
2. Color Theme Preference
3. Hidden preference (if they're displayed as online)
4. Recently viewed pages

Authentication is done through short-lived tokens (30 minutes). When logged in, a refresh token is also provided, which is valid for two weeks. Refresh tokens can be exchanged for a new auth token and refresh token.

Email confirmation, changing password or changing email is also done through long-lived tokens. Like refresh tokens, these can be revoked at any time. For example, after changing password, all refresh tokens for that user are revoked so the user must authenticate with email/password again.

### Conversations

Conversations come in two varities: private and group. A private conversation is between two users, and new users cannot be added at any time. A group conversation can have an alias. All conversations have a unique public and private key per individual (stored in the `encryption_keys` table). These are stored in the database under encryption using the [Cloak Ecto](https://hexdocs.pm/cloak_ecto/readme.html) library. Since the keys are generated by the client, no messages should be sent to a conversation until each client has generated and transmitted keys.

### Messages

Messages are pieces of text sent in a specific conversation by one user. When a user sends a message, it must be sent as a series of messages that are already encrypted with the public keys of everyone in a conversation. In terms of the database, each message is stored separately with the ID of the recipient. All messages sent as part of this point to a singular message group, which has the name of the sender. When retrieving messages from a database for a specific user, each message group will be retrieved but only the message for that specific users.

## Rest(ish) API

All values for payloads and return values are using example data. The field names and types are correct.

The REST-ish API for client interaction are as follows:

### POST `/auth/register`

Create a user with an optional display name.
Payload:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!",
  "display_name": "My Cool Name" // Optional
}
```

Return payload (if successful):

```json
{
  "user": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "email": "test@example.com",
    "display_name": "test@example.com", // Defaults to the email if no display name is given
    "hidden": false,
    "theme": "day", // Options are right now day and night
    "magnification": 1.0, // Value between 0.7 and 1.4
    "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"] // Array of strings that are to be interpreted as recently viewed pages
  },
  "conversations": [
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "private": false,
      "alias": "Besties 4eva", // Nullable
      "inserted_at": "2024-01-01T23:38:41.183Z",
      "updated_at": "2024-01-01T23:38:41.183Z"
    }
  ],
  "users": [
    // Information for all users in conversations with the user.
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "email": "test@example.com",
      "display_name": "test@example.com"
    }
  ],
  "auth_token": "SFMyNTY.g2gDbQAAACQ0YjJlMWIwZi03NDBkLTQxMWQtODEzMy1kYzlhYjY2NDBiNWVuBgALsmbHjAFiAAAHCA.fAQMbNHGcPrFJC9KoCNTA03rMgGdXc112Y_shoyRm9g",
  "refresh_token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

### POST `/auth/login`

Log in with an email and password to get an auth token and password.
Payload:

```json
{
  "email": "test@example.com",
  "password": "VerySecurePassword1!"
}
```

Returns the same data as the POST `/auth/register` endpoint.

### POST `/auth/refresh`

Exchange a refresh token for a new auth token and refresh token.

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

Return the same data (if successful) as `/auth/register`.

### POST `/auth/confirm`

Mark an email address as confirmed. When a user registers (and emailing functionality is complete), an email is sent to their email address to confirm it. No functionality is hidden behind email confirmation.

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

If successful, a 204 with no content will be returned.

### POST `/auth/password/request`

Payload:

```json
{
  "email": "test@example.com"
}
```

If a user is discovered corresponding to the email, a 204 will be returned and an email will be sent to the email address with a password reset token.

### POST `/auth/password/confirm`

Returns the user that the token belongs to.

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ"
}
```

Return data:

```json
{
  "success": true,
  "user": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "email": "test@example.com",
    "display_name": "test@example.com"
  }
}
```

### POST `/auth/password/reset`

A password reset token will set the password to a new value and revoke all tokens (refresh, confirmation etc.).

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ",
  "password": "VerySecurePassword1!", // Current password
  "new_password": "VerySecurePassword2!", // New Password
  "new_password_confirmation": "VerySecurePassword2!" // Must match the new password exactly
}
```

Returns a 204 if successful.

## API Endpoints

All API endpoints require a `Authorization` header with a value of `Bearer <token>`. A token will only be valid for 30 minutes and identifies the user in the payload.

### POST `/api/signout_all`

Forces all refresh tokens for a given user to be revoked. No payload is required. A 204 response with no data will be returned.

### POST `/api/token/email_confirm`

Requests a new email confirmation token. No payload is required. A 204 response with no data will be returned.

### POST `/api/token/email_change`

Requests a new email change token. No payload is required. A 204 response with no data will be returned.

### PATCH `/api/password`

Changes a user's password. This is different from POST `/auth/password/reset` because it uses a token.

Payload:

```json
{
  "password": "VerySecurePassword1!", // Current password
  "new_password": "VerySecurePassword2!", // New Password
  "new_password_confirmation": "VerySecurePassword2!" // Must match the new password exactly
}
```

If the request is successful then a 204 will be returned and all tokens will be reset for the user.

### PATCH `/api/email`

Change a user's email. It requires both the email change token and the authentication token, meaning it can only happen if the user is logged in.

Payload:

```json
{
  "token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ",
  "email": "test@example.com",
  "password": "VerySecurePassword1!"
}
```

If successful, a 204 with no data will be returned.

### PATCH `/api/profile`

Changes the user profile settings including:

1. Text Magnification
2. Theme
3. Recents
4. Hidden status

Payload:

```json
{
  "hidden": false,
  "theme": "day", // Options are right now day and night
  "magnification": 1.0, // Value between 0.7 and 1.4
  "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"] // Array of strings that are to be interpreted as recently viewed pages
}
```

Returned data if successful:

```json
{
  "hidden": false,
  "theme": "day", // Options are right now day and night
  "magnification": 1.0, // Value between 0.7 and 1.4
  "recents": ["/chat/1787a16a-e6a3-4a22-bfdc-0f0ac7253ad5"] // Array of strings that are to be interpreted as recently viewed pages
}
```

### GET `/api/messages`

Get paginated messages for a conversation. It takes the following required query parameters:

1. `conversation_id` - the UUID of the conversation

Optional query parameters:

1. `page_token` - the page token from the last page retrieved. If no page token is given then the messages will be paginated from the latest messages for the conversation.
2. `page_size` - the amount of messages to retrieve.

The returned data if successful is:

```json
{
  "items": [
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "sender": "5161cb32-2d85-4846-897d-10c336ce701c",
      "content": "Hello", // This will be encrypted using the public key for the user for the conversation
      "inserted_at": "2024-01-01T23:38:41.183Z",
      "updated_at": "2024-01-01T23:38:41.183Z",
      "message_group": "5161cb32-2d85-4846-897d-10c336ce701c" // Message group ID is needed when updating/deleting the message
    }
  ],
  "page_token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ" // Null if there are no more messages for the conversation
}
```

### GET `/api/users`

Get a page of users. It takes two optional query parameters:

1. `page_token` - the page token from the last page retrieved. If no page token is given then the messages will be paginated from the latest messages for the conversation.
2. `page_size` - the amount of messages to retrieve.

The returned data if successful is:

```json
{
  "items": [
    {
      "id": "5161cb32-2d85-4846-897d-10c336ce701c",
      "email": "test@example.com",
      "display_name": "test@example.com"
    }
  ],
  "page_token": "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ" // Null if there are no more messages for the conversation
}
```

### GET `/api/conversations/private/:user_id`

Returns if the user by the auth token is already in a private conversation with the user by the given user ID. No query parameters will be checked. Returns the following data:

```json
{
  "conversation_id": "5161cb32-2d85-4846-897d-10c336ce701c" // Null if no conversation is found
}
```

## Socket Interactions

The socket interfaces are divided into three channels (a Phoenix abstraction over sockets):
`system:general`
`user:{uuid}`
`conversation:{uuid}`

A conversation channel will be opened per converstion that the user is involved in, while the user will only be connected to one `user` channel for their ID and one connection to the system general channel. All token interactions must include the auth token in the payload under the `token` key, e.g.

```json
{
  "token": "SFMyNTY.g2gDbQAAACQ0YjJlMWIwZi03NDBkLTQxMWQtODEzMy1kYzlhYjY2NDBiNWVuBgALsmbHjAFiAAAHCA.fAQMbNHGcPrFJC9KoCNTA03rMgGdXc112Y_shoyRm9g"
}
```

### System Channel

The `system:general` receives messages from users which isn't targeted towards a specific conversation. There are two main functions:

1. Tracking user presence (logged-in status). It decides the three possibilities: 1. Logged in, 2. Not Logged in, 3. Logged in but hidden.
1. Changing the user's display name/hidden status.
1. Starting a conversation.

The following events are received:

#### set_hidden

Set the hidden status of the user. If a user is hidden, they will not be displayed as online even if they are logged in.

Payload:

```json
{
  "hidden": true // Boolean that represents the hidden status
}
```

Event receive the `"message_sent"` payload in the reply. The status of the user will be changed in the presence.

#### set_display_name

Set the display name for the user.

Payload:

```json
{
  "display_name": "New Display Name"
}
```

If successful, the following data will be transmitted on the `system:general` channel to all users.

```json
{
  "user_id": "5161cb32-2d85-4846-897d-10c336ce701c",
  "display_name": "New Dislay Name"
}
```

#### start_group_conversation

Begin a group conversation.

Payload:

```json
{
  "user_ids": ["5161cb32-2d85-4846-897d-10c336ce701c"],
  "public_key": {}, // Specifications for a public and private key can be found in the add encryption keys migration
  "private_key": {},
  "alias": "Besties 4eva" // Optional
}
```

If successful, it will send transmission on each relevant user's `user:<uuid>` channel with the following data:

```json
{
  "conversation": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "private": false,
    "alias": "Besties 4eva", // Nullable
    "inserted_at": "2024-01-01T23:38:41.183Z",
    "updated_at": "2024-01-01T23:38:41.183Z"
  },
  "user_ids": ["5161cb32-2d85-4846-897d-10c336ce701c"] // The IDs of all users in the conversation
}
```

#### start_private_conversation

Begin a private conversation. A private conversation cannot have an alias, and the `private` field will have a value of `true`.

Payload:

```json
{
  "other_user_id": "5161cb32-2d85-4846-897d-10c336ce701c",
  "public_key": {},
  "private_key": {}
}
```

If successful, the handling is identical to `start_private_conversation`.

### User Channel

The user channel is to send a message from the server to a specific user with some information that is relevant to them. There is no messages to be transmitted to the server. There are four events that will be transmitted on this channel.

#### new_conversation

A new conversation (either private or group) will be transmitted when a new conversation has started and the user is in that conversation.

Payload:

```json
{
  "conversation": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "private": false,
    "alias": "Besties 4eva", // Nullable
    "inserted_at": "2024-01-01T23:38:41.183Z",
    "updated_at": "2024-01-01T23:38:41.183Z"
  },
  "user_ids": ["5161cb32-2d85-4846-897d-10c336ce701c"] // The IDs of all users in the conversation
}
```

#### new_message

A conversation has a message sent in it. The reason that this is not transmitted on the conversation's channel is because each message is actually a series of messages encrypted with the public keys of every user in the channel (including the sender). Each user only receives the messages encrypted with their public key for the conversation.

Payload:

```json
{
  "conversation_id": "5161cb32-2d85-4846-897d-10c336ce701c",
  "message": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "sender": "5161cb32-2d85-4846-897d-10c336ce701c",
    "content": "Hello", // This will be encrypted using the public key for the user for the conversation
    "inserted_at": "2024-01-01T23:38:41.183Z",
    "updated_at": "2024-01-01T23:38:41.183Z",
    "message_group": "5161cb32-2d85-4846-897d-10c336ce701c" // Message group ID is needed when updating/deleting the message
  }
}
```

#### edit_message

When a message is edited, a new message encrypted with every public key will be transmitted. The procedure is identical to `new_message` above.

### Conversation Channel

The conversation channel sends and receives events. It handles interactions a user can do with a channel: 1. Leaving it, 2. Sending/Editing/Deleting messages, 3. Changing the conversation (alias and/or users in the conversation), 4. Start/finish typing, 5. If a user has read the conversation, and 6. Transmitting/receiving public keys.

Upon joining a conversation, the following will be transmitted to a user:

```json
{
  "conversation": {
    "id": "5161cb32-2d85-4846-897d-10c336ce701c",
    "private": false,
    "alias": "Besties 4eva", // Nullable
    "inserted_at": "2024-01-01T23:38:41.183Z",
    "updated_at": "2024-01-01T23:38:41.183Z"
  },
  "read_times": {
    // Read times are an object of the users' IDs to their latest read times
    "5161cb32-2d85-4846-897d-10c336ce701c": "2024-01-01T23:38:41.183Z"
  },
  "messages": {

    "items": [
      {
        "id": "5161cb32-2d85-4846-897d-10c336ce701c",
        "sender": "5161cb32-2d85-4846-897d-10c336ce701c",
        "content": "Hello", // This will be encrypted using the public key for the user for the conversation
        "inserted_at": "2024-01-01T23:38:41.183Z",
        "updated_at": "2024-01-01T23:38:41.183Z",
        "message_group": "5161cb32-2d85-4846-897d-10c336ce701c" // Message group ID is needed when updating/deleting the message
      }
    ],
    "JOebHW8SWnSchOmVwhDJKafyWhCuYRV1CidfR3PwsgQ" // Null if there are no more messages for the conversation
  },
  "public_keys": { // Object with the keys beign the user IDs and the values being the corresponding public keys
      "5161cb32-2d85-4846-897d-10c336ce701c": {}
  },
  "private_key": {}
}
```

#### change_alias

Set the alias for the conversation.

Payload:

```json
{
  "alias": "Besties 4eva"
}
```

If successful, the `update_alias` event will be transmitted to all participants in the conversation with the new conversation alias.

#### leave_conversation

A user has left a group conversation. There is no associated payload. If successful, the `leave_conversation` event will be transmitted to all participants in the conversation with the following data:

```json
{
  "user_id": "5161cb32-2d85-4846-897d-10c336ce701c"
}
```

#### send_message

The user is transmitting a set of messages encrypted with the public key of each user.

Payload:

```json
{
  "encrypted_messages": {
    "5161cb32-2d85-4846-897d-10c336ce701c": "hello" // Keys of this object are the user ids of each user, and the values are the messages encrypted in the users' public keys
  }
}
```

This will trigger the `new_message` event in the `user:<uuid>` channel as described above.

#### edit_message

The user is transmitting an update for a message group. Only the original sender for a message can edit it.

Payload:

```json
{
  "message_group_id": "5161cb32-2d85-4846-897d-10c336ce701c",
  "encrypted_messages": {
    "5161cb32-2d85-4846-897d-10c336ce701c": "hello" // Keys of this object are the user ids of each user, and the values are the messages encrypted in the users' public keys
  }
}
```

Like the `send_message` event above, the `edit_message` event will be sent in the `user:<uuid>` channel as described above.

#### delete_message

The sender of messages wish to delete all messages in a message group.

Payload:

```json
{
  "message_group_id": "5161cb32-2d85-4846-897d-10c336ce701c"
}
```

If successful, the `delete_message` event will be triggered in the channel with the following data:

```json
{
  "message_group_id": "5161cb32-2d85-4846-897d-10c336ce701c"
}
```

#### start_typing

The user has begun typing. There is no payload. If successful, the `start_typing` event will be transmitted to all participants in the conversation with the following data:

```json
{
  "user_id": "5161cb32-2d85-4846-897d-10c336ce701c"
}
```

#### finish_typing

The user has finished typing. There is no payload. If successful, the `finish_typing` event will be transmitted to all participants in the conversation with the following data:

```json
{
  "user_id": "5161cb32-2d85-4846-897d-10c336ce701c"
}
```

#### read_conversation

The user has read the conversation so far. This is used to indicate which users have seen which messages. There is no payload associated with the event, and the `read_conversation` event will be transmitted to all participants in the conversation with the following data:

```json
{
  "user_id": "5161cb32-2d85-4846-897d-10c336ce701c"
}
```

#### modify_conversation

A group conversation has new members added to it and optionally the alias may have changed.

Payload:

```json
{
  "new_members": ["5161cb32-2d85-4846-897d-10c336ce701c"],
  "alias": "Besties 4eva" // Optional
}
```

If successful, an identical payload to a new conversation is sent to all users in the conversation. For all users already in the conversation, the ID will already be existent and details will overwrite previous details.

#### set_encryption_keys

Since encryption keys are generated on the client side, each user in a conversation must transmit a public and private key upon joining a conversation for the first time.

Payload:

```json
{
  "public_key": {},
  "private_key": {}
}
```

If successful, the `set_encryption_keys` event will be transmitted to all users in the channel with the following data:

```json
{
  "user_id": "5161cb32-2d85-4846-897d-10c336ce701c",
  "public_key": {}
}
```

## What's Missing

1. Testing and Documentation
1. Fix the email system (emails are not sent so confirmation/changing email and resetting password is not available)
1. Streamline functions/modules, remove redundancies and make sure domain code is entirely contained within it
1. Add OAPI docs for endpoints/socket interactions.
